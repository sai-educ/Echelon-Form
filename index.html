Absolutely—here’s the updated single-file HTML. I kept the tool exactly as before and added a top-right “How to Use” menu with step-by-step instructions and **Learning Goals** in both **English** and **తెలుగు** (Telugu). Just save as, e.g., `normal-form-lab.html` and open in your browser or host on GitHub Pages.

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Matrix Normal Form — Interactive Lab (Rank via Row & Column Ops)</title>
<style>
  :root{
    --bg:#0e1220; --panel:#151a2e; --ink:#eaf0ff; --muted:#b7bee2;
    --accent:#7fd4ff; --ok:#3ad59a; --warn:#ffd074; --danger:#ff8aa5;
    --grid:#232744; --pivot:#22d39a; --focus:#e8ff7d; --zero:#6fb3ff; --id:#9fffa8;
    --overlay:#00000090;
  }
  html,body{height:100%}
  body{
    margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans";
    color:var(--ink); background: radial-gradient(1200px 700px at 15% -10%, #1a2142 0%, #0e1220 60%) fixed;
  }

  /* ---------- Top-right HOW-TO menu ---------- */
  .howto-anchor{position:fixed; top:12px; right:16px; z-index:1001}
  .howto-btn{
    background:#1d2340; border:1px solid #3a4470; color:var(--ink);
    border-radius:999px; padding:10px 14px; font-size:14px; cursor:pointer;
  }
  .howto-btn:hover{border-color:#4a5790}
  .backdrop{position:fixed; inset:0; background:var(--overlay); display:none; z-index:1000}
  .backdrop.open{display:block}
  .howto-panel{
    position:fixed; top:56px; right:16px; width:420px; max-width:95vw;
    background:linear-gradient(180deg,#161b32 0%,#13182b 100%);
    border:1px solid #242946; border-radius:16px; padding:14px;
    box-shadow:0 18px 40px #00000070; z-index:1002; display:none;
  }
  .howto-panel.open{display:block}
  .howto-head{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px}
  .howto-title{font-size:16px; font-weight:700}
  .close-btn{background:#171b30; border:1px solid #2b345c; color:var(--ink); border-radius:10px; padding:8px 10px; cursor:pointer}
  .close-btn:hover{border-color:#3e4872}
  .lang-tabs{display:flex; gap:6px; margin:6px 0 10px}
  .tab{background:#121735; border:1px solid #2a3256; color:var(--muted); padding:6px 10px; border-radius:999px; cursor:pointer; font-size:13px}
  .tab[aria-selected="true"]{color:#101425; background:#9fd7ff; border-color:#9fd7ff; font-weight:700}
  .howto-section{border:1px solid #262c48; background:#12182e; border-radius:10px; padding:10px; margin-top:8px}
  .howto-section h3{margin:0 0 6px; font-size:15px}
  .howto-section ol{margin:.35em 0 .2em 1.2em} .howto-section li{margin:.25em 0}
  .muted{color:var(--muted)}

  header{max-width:1200px; margin:0 auto; padding:26px 16px 8px}
  h1{margin:0 0 6px; font-size:clamp(22px,3.2vw,34px)}
  .sub{color:var(--muted); max-width:980px}
  main{max-width:1200px; margin:12px auto 40px; padding:0 16px; display:grid; gap:16px; grid-template-columns:1.25fr .95fr}
  @media (max-width:1050px){ main{grid-template-columns:1fr} }

  .card{background:linear-gradient(180deg,#161b32 0%,#13182b 100%); border:1px solid #242946; border-radius:16px; padding:14px; box-shadow:0 10px 28px #00000045, inset 0 1px 0 #2a2f4a33}
  h2{margin:0 0 8px; font-size:18px}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .spacer{height:8px}
  .badge{display:inline-flex; gap:6px; align-items:center; font-size:12px; padding:4px 8px; border-radius:999px; background:#1a1f38; border:1px solid #2a3256}
  .tag{display:inline-flex; align-items:center; gap:6px; font-size:12px; padding:3px 8px; border-radius:999px; border:1px dashed #2a2f47; background:#141a34}
  .dot{width:10px; height:10px; border-radius:50%}
  .dot.pivot{background:var(--pivot)} .dot.zero{background:var(--zero)} .dot.focus{background:var(--focus)}
  .dot.id{background:var(--id)} .dot.warn{background:var(--warn)} .dot.danger{background:var(--danger)}

  button, select, input[type="number"], input[type="text"]{
    background:#1d2340; border:1px solid #31385b; color:var(--ink); border-radius:10px; padding:10px 12px; font-size:14px; outline:none;
  }
  button:hover{border-color:#3e4872} button:active{transform:translateY(1px)}
  button.primary{background:linear-gradient(180deg,#2a5a9a,#274b84); border-color:#3c63a0}
  button.ghost{background:#171b30}
  button.ok{background:#173528; border-color:#2f6b4c}
  button.warn{background:#3a3012; border-color:#69561b}
  button.danger{background:#3a1c28; border-color:#6b2b45}
  .pill{display:inline-flex; align-items:center; gap:6px; padding:8px 12px; border:1px solid #2a2f47; border-radius:999px; background:#131a34; color:var(--muted)}

  .matrix-wrap{
    position:relative; padding:14px; border-radius:14px;
    background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0)),
                repeating-linear-gradient(0deg, transparent 0 31px, #14182a 31px 32px),
                repeating-linear-gradient(90deg, transparent 0 31px, #14182a 31px 32px);
    border:1px solid #282d46; overflow:hidden;
  }
  .brackets::before,.brackets::after{
    content:""; position:absolute; top:8px; bottom:8px; width:8px; border:2px solid #2f3554; border-left:none; border-right:none;
  }
  .brackets::before{left:6px; border-left:3px solid #2f3554; border-radius:10px 0 0 10px}
  .brackets::after{right:6px; border-right:3px solid #2f3554; border-radius:0 10px 10px 0}
  .matrix{display:grid; gap:6px}
  .cell{position:relative}
  .cell input{
    width:76px; padding:10px; text-align:center; font-size:16px; color:var(--ink);
    background:#182044; border:1px solid #2b3356; border-radius:10px; transition:border-color .15s, box-shadow .15s;
  }
  .cell input:focus{border-color:#4f5ba2; box-shadow:0 0 0 2px #4f5ba233}
  .pivotMark{position:absolute; inset:auto auto -6px 50%; transform:translateX(-50%); font-size:11px; padding:2px 6px; border-radius:999px; background:#0e3929; color:#b8ffe0; border:1px solid #23d18b55}
  .zeroMark{position:absolute; inset:-6px -6px auto auto; font-size:10px; padding:2px 6px; border-radius:6px; background:#0d2b55; color:#cfe3ff; border:1px solid #67a7ff55}
  .idMark{position:absolute; inset:-6px auto auto -6px; font-size:10px; padding:2px 6px; border-radius:6px; background:#0d3a24; color:#caffd5; border:1px solid #9fffa855}

  .stair{position:absolute; inset:8px; pointer-events:none}
  .idBlock{position:absolute; border:2px dashed #9fffa866; border-radius:8px}

  .log{background:#12162a; border:1px solid #242846; border-radius:12px; padding:10px; height:220px; overflow:auto; font-family:ui-monospace,Menlo,Consolas,monospace; font-size:13px}
  .kpis{display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-top:8px}
  .kpi{background:#12162a; border:1px solid #242846; border-radius:10px; padding:8px; text-align:center}
  .kpi .label{font-size:11px; color:var(--muted)} .kpi .value{font-size:16px; margin-top:4px}

  details{border:1px solid #262c48; background:#12182e; border-radius:10px; padding:10px}
  summary{cursor:pointer; font-weight:600}

  footer{max-width:1200px; margin:8px auto 40px; padding:0 16px; color:var(--muted); font-size:13px}
  a{color:var(--accent)}
</style>
</head>
<body>
  <!-- Top-right HOW-TO menu -->
  <div class="howto-anchor">
    <button id="howBtn" class="howto-btn" aria-haspopup="dialog" aria-controls="howPanel">❓ How to Use</button>
  </div>
  <div id="howBackdrop" class="backdrop" tabindex="-1" aria-hidden="true"></div>
  <div id="howPanel" class="howto-panel" role="dialog" aria-modal="true" aria-labelledby="howTitle" aria-hidden="true">
    <div class="howto-head">
      <div id="howTitle" class="howto-title">How to Use • వాడుక మార్గదర్శకం</div>
      <button id="howClose" class="close-btn" aria-label="Close">✕</button>
    </div>
    <div class="lang-tabs" role="tablist" aria-label="Language tabs">
      <button id="tabEN" class="tab" role="tab" aria-selected="true" aria-controls="panelEN">English</button>
      <button id="tabTE" class="tab" role="tab" aria-selected="false" aria-controls="panelTE">తెలుగు</button>
    </div>

    <!-- English panel -->
    <section id="panelEN" class="howto-section" role="tabpanel" aria-labelledby="tabEN">
      <h3>Learning Goals</h3>
      <ul class="muted">
        <li>Define Normal Form: <code>N = diag(I<sub>r</sub>, 0)</code> and identify <b>rank r</b>.</li>
        <li>Compute rank using <b>row and column operations</b>.</li>
        <li>Execute: pivot selection, scaling to 1, zeroing row/column, iterate k.</li>
        <li>Interpret operations as <code>P·A·Q = N</code> with elementary matrices.</li>
        <li>Connect rank to solvability and invertibility (square A invertible ⟺ r = n).</li>
      </ul>
      <h3 style="margin-top:8px">Step-by-Step</h3>
      <ol>
        <li><b>Set size</b>: choose <i>Rows</i> & <i>Cols</i> → click <b>Resize</b>.</li>
        <li><b>Enter values</b> or use <b>Preset A/B</b> or <b>Randomize</b>.</li>
        <li>Press <b>Next Step</b> to reduce to Normal Form: find a nonzero in the (k,k) submatrix, swap rows/cols to (k,k), scale so pivot=1, zero other entries in column k (row ops) and row k (column ops), then advance k.</li>
        <li>Use <b>Finish to Normal Form</b> to complete automatically.</li>
        <li>Practice with <b>Manual Row/Column Operations</b> (Swap, Scale, Add Multiple).</li>
        <li>Click <b>Check Normal Form</b> anytime to verify the target shape.</li>
        <li>Read the <b>KPIs</b>: Rank (r), Identity size, Normal Form status. Use <b>Narration</b> and <b>Operation Log</b> to follow the reasoning.</li>
      </ol>
      <p class="muted" style="margin-top:6px">Tip: Everything outside the top-left <code>I<sub>r</sub></code> must be 0 in Normal Form.</p>
    </section>

    <!-- Telugu panel -->
    <section id="panelTE" class="howto-section" role="tabpanel" aria-labelledby="tabTE" hidden>
      <h3>అభ్యాస లక్ష్యాలు (Learning Goals)</h3>
      <ul class="muted">
        <li><b>Normal Form</b> నిర్వచనం: <code>N = diag(I<sub>r</sub>, 0)</code> మరియు <b>rank r</b> గుర్తించడం.</li>
        <li><b>వరుస & కాలమ్ ఆపరేషన్లతో</b> rank ని గణించడం.</li>
        <li>దశలు: <i>pivot</i> ఎంపిక, 1కి <i>scale</i> చేయడం, అదే వరుస/కాలమ్ లోని ఇతర విలువలను 0 చేయడం, తరువాత kని పెంచడం.</li>
        <li>ప్రతి చర్యను <code>P·A·Q = N</code> రూపంలో elementary matrices ద్వారా అర్థం చేసుకోవడం.</li>
        <li>rank ని solvability మరియు invertibility (చతురస్ర A invertible ⟺ r = n) తో కలపడం.</li>
      </ul>
      <h3 style="margin-top:8px">దశలవారీ వాడుక</h3>
      <ol>
        <li><b>పరిమాణం</b> ఎంచుకోండి: <i>Rows</i>, <i>Cols</i> ఇవ్వండి → <b>Resize</b> నొక్కండి.</li>
        <li><b>విలువలు నమోదు</b> చేయండి లేదా <b>Preset A/B</b>, <b>Randomize</b> వాడండి.</li>
        <li><b>Next Step</b> నొక్కండి: (k,k) ఉపమాట్రిక్స్ లో నాన్జీరో అంశాన్ని వెతికి (k,k)కి రప్పించేందుకు వరుస/కాలమ్ <i>swap</i> చేయండి, pivot ని 1కి <i>scale</i> చేయండి, తరువాత kవ కాలమ్ లోని మిగతా ఎంట్రీలను (row operations తో) 0 చేయండి, kవ వరుసలోని ఎంట్రీలను (column operations తో) 0 చేయండి; తరువాత k ని పెంచండి.</li>
        <li><b>Finish to Normal Form</b> నొక్కితే ఆటోమేటిక్ గా పూర్తవుతుంది.</li>
        <li><b>Manual Row/Column Operations</b> (Swap, Scale, Add Multiple) తో సాధన చేయండి.</li>
        <li>ఎప్పుడైనా <b>Check Normal Form</b> నొక్కి లక్ష్య ఆకారాన్ని తనిఖీ చేయండి.</li>
        <li><b>KPIs</b> చూడండి: Rank (r), Identity size, Normal Form స్థితి. <b>Narration</b> & <b>Operation Log</b> ద్వారా చర్యల తర్కం అర్థం చేసుకోండి.</li>
      </ol>
      <p class="muted" style="margin-top:6px">సూచన: Normal Form లో <code>I<sub>r</sub></code> బ్లాక్ వెలుపల అన్నీ 0 అయి ఉండాలి.</p>
    </section>
  </div>

<header>
  <h1>Normal Form of a Matrix — Interactive Rank Lab</h1>
  <p class="sub">
    Goal: reduce a matrix <b>A</b> by <b>row and column operations</b> to its <b>Normal Form</b> 
    <code>N = diag(I<sub>r</sub>, 0)</code>, where <b>r = rank(A)</b>. Use the controls to perform operations 
    yourself or step through the auto method. Labels show pivots, the growing identity block, and zeroed zones.
  </p>
</header>

<main>
  <!-- LEFT: Matrix & Controls -->
  <section class="card">
    <div class="row" aria-label="Matrix size and presets">
      <div class="pill">Rows: <input id="rows" type="number" min="1" max="7" value="3" style="width:64px; margin-left:6px"></div>
      <div class="pill">Cols: <input id="cols" type="number" min="1" max="7" value="4" style="width:64px; margin-left:6px"></div>
      <button id="resize">Resize</button>
      <span class="spacer" style="width:8px"></span>
      <button id="presetA" class="ghost">Preset A</button>
      <button id="presetB" class="ghost">Preset B</button>
      <button id="random" class="ghost">Randomize</button>
      <button id="reset" class="ghost">Clear</button>
    </div>

    <div class="spacer"></div>

    <div class="matrix-wrap brackets" aria-label="Matrix grid">
      <div id="stair" class="stair" aria-hidden="true"></div>
      <div id="matrix" class="matrix"></div>
    </div>

    <div class="spacer"></div>

    <div class="row">
      <span class="tag"><span class="dot pivot"></span> Pivot position</span>
      <span class="tag"><span class="dot id"></span> Inside identity block</span>
      <span class="tag"><span class="dot zero"></span> Must be zero</span>
      <span class="tag"><span class="dot focus"></span> Current pivot focus</span>
    </div>

    <div class="spacer"></div>

    <div class="row" aria-label="Auto controls">
      <button id="next" class="primary">Next Step ▷</button>
      <button id="finish" class="ok">Finish to Normal Form</button>
      <button id="check" class="ghost">Check Normal Form</button>
      <span class="muted">Auto uses row <i>and</i> column pivoting: we seek a nonzero entry, bring it to (k,k), scale to 1, zero its row & column, then advance.</span>
    </div>

    <div class="spacer"></div>

    <details>
      <summary>Manual Row & Column Operations</summary>
      <div class="spacer"></div>
      <div class="row">
        <div class="pill">Swap R<select id="rSwapA"></select> ↔ R<select id="rSwapB"></select></div>
        <button id="rSwapBtn">Swap Rows</button>
      </div>
      <div class="spacer"></div>
      <div class="row">
        <div class="pill">Swap C<select id="cSwapA"></select> ↔ C<select id="cSwapB"></select></div>
        <button id="cSwapBtn">Swap Cols</button>
      </div>
      <div class="spacer"></div>
      <div class="row">
        <div class="pill">Scale R<select id="rScaleRow"></select> by <input id="rScaleK" type="number" value="2" step="0.1" style="width:84px"></div>
        <button id="rScaleBtn">Scale Row</button>
      </div>
      <div class="spacer"></div>
      <div class="row">
        <div class="pill">Scale C<select id="cScaleCol"></select> by <input id="cScaleK" type="number" value="2" step="0.1" style="width:84px"></div>
        <button id="cScaleBtn">Scale Col</button>
      </div>
      <div class="spacer"></div>
      <div class="row">
        <div class="pill">R<select id="rAddDest"></select> ← R<select id="rAddDest2"></select> + (<input id="rAddK" type="number" value="-1" step="0.1" style="width:84px">)·R<select id="rAddSrc"></select></div>
        <button id="rAddBtn">Add to Row</button>
      </div>
      <div class="spacer"></div>
      <div class="row">
        <div class="pill">C<select id="cAddDest"></select> ← C<select id="cAddDest2"></select> + (<input id="cAddK" type="number" value="-1" step="0.1" style="width:84px">)·C<select id="cAddSrc"></select></div>
        <button id="cAddBtn">Add to Col</button>
      </div>
      <div class="spacer"></div>
      <div class="muted" style="font-size:13px">Tips: To zero an entry below/above a pivot in column <em>k</em>, add a multiple of the pivot row. To zero entries left/right of pivot in row <em>k</em>, add multiples of the pivot column.</div>
    </details>
  </section>

  <!-- RIGHT: Lesson, Narration, KPIs, Log -->
  <aside class="card">
    <h2>Mini-Lesson: Normal Form (for Rank)</h2>
    <div class="muted" id="lesson">
      <p><b>What:</b> Normal Form over ℝ (or any field) reduces a matrix A by <i>row and column</i> operations into <code>N = diag(I<sub>r</sub>, 0)</code>. The number r is the <b>rank</b> of A.</p>
      <p><b>Why:</b> It cleanly separates the “information” (an identity block) from redundancy (zeros). Perfect for reasoning about solvability, dimensions of solution spaces, and invertibility (square A is invertible iff r = n).</p>
      <p><b>How (algorithm):</b> For k = 1…:
        <ol style="margin:.35em 0 .2em 1.2em">
          <li>Find a nonzero entry in the submatrix starting at (k,k). Swap rows/cols to move it to (k,k).</li>
          <li>Scale R<sub>k</sub> and/or C<sub>k</sub> so a<sub>kk</sub>=1.</li>
          <li>Use row/column additions to zero all other entries in row k and column k.</li>
          <li>Increment k and repeat. Stop when no nonzero remains. The first k−1 pivots form I<sub>r</sub>.</li>
        </ol>
      </p>
      <p class="muted">Concept link: every step corresponds to multiplying by elementary matrices P (left) and Q (right), so <code>P · A · Q = N</code>.</p>
    </div>

    <div class="spacer"></div>

    <h2>Step Narration</h2>
    <div id="narr" class="muted" style="min-height:44px">Enter a matrix or pick a preset. Then click <b>Next Step</b> to begin normal-form reduction.</div>

    <div class="spacer"></div>

    <div class="kpis">
      <div class="kpi"><div class="label">Rank (r)</div><div id="rank" class="value">–</div></div>
      <div class="kpi"><div class="label">Identity size</div><div id="idSize" class="value">I<sub>0</sub></div></div>
      <div class="kpi"><div class="label">Normal Form?</div><div id="nf" class="value">–</div></div>
    </div>

    <div class="spacer"></div>

    <h2>Operation Log</h2>
    <div id="log" class="log" aria-live="polite"></div>

    <div class="spacer"></div>

    <details>
      <summary>Quick Checks (ask students!)</summary>
      <ul style="margin:.4em 0 0 1.1em">
        <li>True/False: If A is 3×5 and rank(A)=3, then the normal form is diag(I<sub>3</sub>,0).</li>
        <li>Which are allowed for normal form? (a) swap rows (b) add multiple of a row (c) scale a column (d) rotate columns — Answer: a,b,c (no geometric rotations).</li>
        <li>Why can normal form reveal rank even when Gaussian elimination alone might be awkward?</li>
      </ul>
    </details>
  </aside>
</main>

<footer>
  Built for an Engineering Mathematics course • Focus: Normal Form & Rank via row and column operations • Try Preset B to see both row and column swaps in action.
</footer>

<script>
/* ===========================
   Utilities
   =========================== */
const EPS = 1e-10;
const NZ = x => Math.abs(x) > EPS;
const nearZero = x => Math.abs(x) < EPS;
const r4 = x => nearZero(x) ? 0 : Math.round(x*10000)/10000;

/* ===========================
   HOW-TO menu behavior
   =========================== */
function openHowto(){
  document.getElementById('howBackdrop').classList.add('open');
  const p = document.getElementById('howPanel');
  p.classList.add('open');
  p.setAttribute('aria-hidden','false');
  document.getElementById('howBtn').setAttribute('aria-expanded','true');
  // focus first tab for accessibility
  document.getElementById('tabEN').focus();
}
function closeHowto(){
  document.getElementById('howBackdrop').classList.remove('open');
  const p = document.getElementById('howPanel');
  p.classList.remove('open');
  p.setAttribute('aria-hidden','true');
  document.getElementById('howBtn').setAttribute('aria-expanded','false');
}
function selectLang(tab){
  const isEN = tab === 'EN';
  const tabEN = document.getElementById('tabEN');
  const tabTE = document.getElementById('tabTE');
  const panelEN = document.getElementById('panelEN');
  const panelTE = document.getElementById('panelTE');
  tabEN.setAttribute('aria-selected', isEN ? 'true' : 'false');
  tabTE.setAttribute('aria-selected', isEN ? 'false' : 'true');
  panelEN.hidden = !isEN;
  panelTE.hidden = isEN;
}

/* ===========================
   Model & DOM
   =========================== */
let R=3, C=4;
let inputs = []; // [r][c] <input>
let stepState = null; // {k, stage, searchR, searchC, elimR, elimC}
let logEl, narrEl;

function createGrid(){
  const grid = document.getElementById('matrix');
  grid.style.gridTemplateColumns = `repeat(${C}, minmax(68px,76px))`;
  grid.innerHTML = '';
  inputs = [];
  for (let r=0;r<R;r++){
    const row=[];
    for (let c=0;c<C;c++){
      const cell = document.createElement('div'); cell.className='cell';
      const inp = document.createElement('input'); inp.type='number'; inp.step='any';
      inp.value = (r===c?1:0);
      inp.setAttribute('aria-label',`Row ${r+1}, Col ${c+1}`);
      inp.addEventListener('input', drawLabels);
      cell.appendChild(inp); grid.appendChild(cell); row.push(inp);
    }
    inputs.push(row);
  }
  refreshSelectors();
  drawLabels();
  setNarr('Enter values, use presets, or press <b>Next Step</b>.');
  clearLog();
}

function getM(){
  const M=[]; for (let r=0;r<R;r++){ const row=[]; for (let c=0;c<C;c++){ row.push(parseFloat(inputs[r][c].value||'0')); } M.push(row); }
  return M;
}
function setM(M){
  R = M.length; C = M[0].length;
  document.getElementById('rows').value = R;
  document.getElementById('cols').value = C;
  createGrid();
  for (let r=0;r<R;r++) for (let c=0;c<C;c++) inputs[r][c].value = r4(M[r][c]);
  drawLabels();
}
function clearM(){ for (let r=0;r<R;r++) for (let c=0;c<C;c++) inputs[r][c].value=0; drawLabels(); }
function randomM(){
  for (let r=0;r<R;r++) for (let c=0;c<C;c++) inputs[r][c].value = ((Math.random()*7)|0)-3;
  drawLabels();
}

/* ===========================
   Row & Column Ops
   =========================== */
function swapRows(M,i,j){ if(i===j)return; const t=M[i]; M[i]=M[j]; M[j]=t; log(`Swap R${i+1} ↔ R${j+1}`); }
function swapCols(M,i,j){ if(i===j)return; for(let r=0;r<R;r++){ const t=M[r][i]; M[r][i]=M[r][j]; M[r][j]=t; } log(`Swap C${i+1} ↔ C${j+1}`); }
function scaleRow(M,i,k){ if(nearZero(k)){ log('<span style="color:#ffd07a">Warning</span>: scale by 0 ignored'); return; } for(let c=0;c<C;c++) M[i][c]=r4(M[i][c]*k); log(`R${i+1} ← ${k}·R${i+1}`); }
function scaleCol(M,j,k){ if(nearZero(k)){ log('<span style="color:#ffd07a">Warning</span>: scale by 0 ignored'); return; } for(let r=0;r<R;r++) M[r][j]=r4(M[r][j]*k); log(`C${j+1} ← ${k}·C${j+1}`); }
function addRow(M,dest,src,k){ for(let c=0;c<C;c++) M[dest][c]=r4(M[dest][c]+k*M[src][c]); log(`R${dest+1} ← R${dest+1} + (${k})·R${src+1}`); }
function addCol(M,dest,src,k){ for(let r=0;r<R;r++) M[r][dest]=r4(M[r][dest]+k*M[r][src]); log(`C${dest+1} ← C${dest+1} + (${k})·C${src+1}`); }
function writeBack(M){ for(let r=0;r<R;r++) for(let c=0;c<C;c++) inputs[r][c].value=r4(M[r][c]); drawLabels(); }

/* ===========================
   Rank & Normal Form Check
   =========================== */
function rank(M){
  // basic row echelon based rank (no column ops needed just to count)
  M = M.map(row=>row.slice());
  let r=0, lead=0;
  for (let i=0;i<R;i++){
    if (lead>=C) return r;
    let j=i;
    while (j<R && nearZero(M[j][lead])) j++;
    if (j===R){ lead++; i--; continue; }
    const tmp=M[i]; M[i]=M[j]; M[j]=tmp;
    const div = M[i][lead]; for (let k=0;k<C;k++) M[i][k]/=div;
    for (let u=0;u<R;u++) if (u!==i){ const m=M[u][lead]; for(let k=0;k<C;k++) M[u][k]-=m*M[i][k]; }
    r++; lead++;
  }
  return r;
}

function isNormalForm(M){
  const r = rank(M);
  // top-left r×r should be identity, everything else 0
  for (let i=0;i<Math.min(r,R);i++){
    for (let j=0;j<Math.min(r,C);j++){
      if (i===j && !nearZero(M[i][j]-1)) return false;
      if (i!==j && !nearZero(M[i][j])) return false;
    }
  }
  for (let i=0;i<R;i++){
    for (let j=0;j<C;j++){
      if (i<r && j<r) continue;
      if (!nearZero(M[i][j])) return false;
    }
  }
  return true;
}

/* ===========================
   Auto Normal Form (stepwise)
   =========================== */
function nextStep(){
  let M = getM();
  if (!stepState){
    stepState = {k:0, stage:'findPivot', searchR:0, searchC:0, elimR:0, elimC:0};
    log('<b>Start normal-form reduction</b>');
  }
  let {k, stage} = stepState;

  // done if k beyond limits or everything zero in submatrix
  if (k>=R || k>=C){
    narr('No more steps. Reached boundary of submatrix.');
    log('<b>Reduction complete</b>');
    stepState=null; drawLabels({focusK:null}); return;
  }

  // Helper: find nonzero in submatrix (r>=k, c>=k)
  function findNonzero(){
    for (let i=k;i<R;i++){
      for (let j=k;j<C;j++){
        if (NZ(M[i][j])) return {i,j};
      }
    }
    return null;
  }

  if (stage==='findPivot'){
    const p = findNonzero();
    if (!p){
      narr(`No nonzero entries in submatrix from (R${k+1},C${k+1}). Rank r = ${k}.`);
      log(`<b>No more pivots</b>; rank = ${k}`);
      stepState=null; drawLabels({focusK:null}); return;
    }
    if (p.i!==k){ swapRows(M,p.i,k); writeBack(M); narr(`Bring a nonzero entry into position (R${k+1}, C${k+1}) by swapping rows.`); drawLabels({focusK:k}); return; }
    if (p.j!==k){ swapCols(M,p.j,k); writeBack(M); narr(`Bring that nonzero into column C${k+1} by swapping columns.`); drawLabels({focusK:k}); return; }
    // now (k,k) nonzero
    stepState.stage='make1';
    narr(`Pivot located at (R${k+1},C${k+1}). Next: scale so pivot becomes 1.`);
    drawLabels({focusK:k}); return;
  }

  if (stage==='make1'){
    const a = M[k][k];
    if (!nearZero(a) && Math.abs(a-1)>1e-9){
      // choose row scaling (or col) — either is fine; use row here for simplicity
      scaleRow(M,k, r4(1/a)); writeBack(M);
      narr(`Scaled R${k+1} so that pivot a₍${k+1},${k+1}₎ = 1.`);
      drawLabels({focusK:k}); stepState.stage='zeroCol'; stepState.elimR=k+1; return;
    } else { stepState.stage='zeroCol'; stepState.elimR=k+1; }
  }

  if (stage==='zeroCol'){
    // zero every entry in column k except row k
    while (stepState.elimR<R && nearZero(M[stepState.elimR][k])) stepState.elimR++;
    if (stepState.elimR>=R){
      // now clear row
      stepState.stage='zeroRow'; stepState.elimC=0; narr(`Column C${k+1} below/above pivot cleared. Now clear row entries left/right of pivot.`); writeBack(M); drawLabels({focusK:k}); return;
    }
    const r2 = stepState.elimR;
    const factor = r4(- M[r2][k] / (nearZero(M[k][k])?1:M[k][k]));
    addRow(M, r2, k, factor); writeBack(M);
    narr(`Zero column entry at (R${r2+1},C${k+1}) by R${r2+1} ← R${r2+1} + (${factor})·R${k+1}.`);
    stepState.elimR++; drawLabels({focusK:k}); return;
  }

  if (stage==='zeroRow'){
    // zero every entry in row k except column k (both left and right)
    while (stepState.elimC<C && (stepState.elimC===k || nearZero(M[k][stepState.elimC]))) stepState.elimC++;
    if (stepState.elimC>=C){
      // pivot fully isolated; advance k
      narr(`Row R${k+1} cleared except pivot. Identity block grew by 1.`);
      writeBack(M); drawLabels({focusK:k+1});
      stepState = {k:k+1, stage:'findPivot', searchR:0, searchC:0, elimR:0, elimC:0};
      return;
    }
    const c2 = stepState.elimC;
    const factor = r4(- M[k][c2] / (nearZero(M[k][k])?1:M[k][k]));
    addCol(M, c2, k, factor); writeBack(M);
    narr(`Zero row entry at (R${k+1},C${c2+1}) by C${c2+1} ← C${c2+1} + (${factor})·C${k+1}.`);
    stepState.elimC++; drawLabels({focusK:k}); return;
  }
}

function finish(){
  let guard=0;
  while(guard++<1500 && stepState!==null){ const before=JSON.stringify(getM()); nextStep(); const after=JSON.stringify(getM()); if (before===after) break; }
}

/* ===========================
   Labels & Identity Block Overlay
   =========================== */
function drawLabels(opts={}){
  const focusK = (typeof opts.focusK==='number') ? opts.focusK : null;
  document.querySelectorAll('.pivotMark,.zeroMark,.idMark').forEach(e=>e.remove());
  const stair = document.getElementById('stair'); stair.innerHTML='';

  const M = getM();
  const r = rank(M);
  document.getElementById('rank').innerHTML = r;
  document.getElementById('idSize').innerHTML = `I<sub>${r}</sub>`;
  document.getElementById('nf').innerHTML = isNormalForm(M) ? 'Yes ✅' : 'No';

  // Identity block overlay (top-left r×r)
  if (r>0){
    const inputRect = inputs[0][0].getBoundingClientRect();
    const lastRect = inputs[Math.min(r-1,R-1)][Math.min(r-1,C-1)].getBoundingClientRect();
    const hostRect = stair.getBoundingClientRect();
    const box = document.createElement('div'); box.className='idBlock';
    box.style.left = (inputRect.left - hostRect.left - 6)+'px';
    box.style.top = (inputRect.top - hostRect.top - 6)+'px';
    box.style.width = (lastRect.right - inputRect.left + 12)+'px';
    box.style.height = (lastRect.bottom - inputRect.top + 12)+'px';
    stair.appendChild(box);
  }

  // Mark pivots (diagonal 1s within current identity zone if any)
  for (let i=0;i<Math.min(r,R,C);i++){
    if (!nearZero(M[i][i]-1)) continue;
    const cell = inputs[i][i].parentElement;
    const pm = document.createElement('div'); pm.className='pivotMark'; pm.textContent='pivot';
    cell.appendChild(pm);
  }

  // Zero-required hints: everything outside r×r should be 0 in target
  for (let i=0;i<R;i++){
    for (let j=0;j<C;j++){
      if (i<r && j<r){
        // identity cell; small mark if non-ideal
        if ( (i===j && Math.abs(M[i][j]-1)>1e-9) || (i!==j && NZ(M[i][j])) ){
          const mark = document.createElement('div'); mark.className='idMark'; mark.textContent='id';
          inputs[i][j].parentElement.appendChild(mark);
        }
      }else{
        if (NZ(M[i][j])){
          const zm = document.createElement('div'); zm.className='zeroMark'; zm.textContent='→0';
          inputs[i][j].parentElement.appendChild(zm);
        }
      }
      // focus styling on row/col of current k
      const inputEl = inputs[i][j];
      if (focusK!==null && (i===focusK || j===focusK)){
        inputEl.style.boxShadow='0 0 0 2px #e8ff7d2e';
        inputEl.style.borderColor='#a1ad3a';
      } else {
        inputEl.style.boxShadow='none';
        inputEl.style.borderColor='#2b3356';
      }
    }
  }
}

/* ===========================
   UI helpers
   =========================== */
function setNarr(html){ narrEl.innerHTML = html; }
function narr(html){ setNarr(html); }
function log(html){ logEl.insertAdjacentHTML('beforeend', `<div>• ${html}</div>`); logEl.scrollTop = logEl.scrollHeight; }
function clearLog(){ logEl.innerHTML=''; }

function refreshSelectors(){
  const rOpts = Array.from({length:R},(_,i)=>`<option value="${i}">${i+1}</option>`).join('');
  const cOpts = Array.from({length:C},(_,i)=>`<option value="${i}">${i+1}</option>`).join('');
  ['rSwapA','rSwapB','rScaleRow','rAddDest','rAddDest2','rAddSrc'].forEach(id=>{ const el=document.getElementById(id); if(el) el.innerHTML=rOpts; });
  ['cSwapA','cSwapB','cScaleCol','cAddDest','cAddDest2','cAddSrc'].forEach(id=>{ const el=document.getElementById(id); if(el) el.innerHTML=cOpts; });
}

/* ===========================
   Presets
   =========================== */
function presetA(){
  // rank 2, needs both row & col work to isolate 2×2 identity
  setM([
    [0, 2, 4, 6],
    [1, 1, 0, 3],
    [2, 2, 0, 6],
  ]);
  narr('Preset A loaded (expect rank 2). Try Next Step to watch row+col pivoting.');
}
function presetB(){
  // rectangular with rank 3
  setM([
    [1, 2, 1, 0, 3],
    [2, 4, 2, 1, 7],
    [0, 1, 1, 1, 2],
  ]);
  narr('Preset B loaded (expect rank 3). Step through to form diag(I3,0).');
}

/* ===========================
   Wire-up
   =========================== */
window.addEventListener('DOMContentLoaded', ()=>{
  logEl = document.getElementById('log');
  narrEl = document.getElementById('narr');

  // How-to menu
  document.getElementById('howBtn').addEventListener('click', ()=>{
    const panel = document.getElementById('howPanel');
    const open = !panel.classList.contains('open');
    if (open) openHowto(); else closeHowto();
  });
  document.getElementById('howClose').addEventListener('click', closeHowto);
  document.getElementById('howBackdrop').addEventListener('click', closeHowto);
  document.addEventListener('keydown', (e)=>{ if (e.key==='Escape') closeHowto(); });
  document.getElementById('tabEN').addEventListener('click', ()=>selectLang('EN'));
  document.getElementById('tabTE').addEventListener('click', ()=>selectLang('TE'));

  // Core controls
  document.getElementById('resize').addEventListener('click', ()=>{
    const r = Math.max(1, Math.min(7, parseInt(document.getElementById('rows').value||'3')));
    const c = Math.max(1, Math.min(7, parseInt(document.getElementById('cols').value||'4')));
    R=r; C=c; createGrid();
  });
  document.getElementById('random').addEventListener('click', ()=>{ randomM(); narr('Random matrix generated.'); });
  document.getElementById('reset').addEventListener('click', ()=>{ clearM(); narr('Matrix cleared. Enter your own values.'); });
  document.getElementById('presetA').addEventListener('click', presetA);
  document.getElementById('presetB').addEventListener('click', presetB);

  document.getElementById('next').addEventListener('click', nextStep);
  document.getElementById('finish').addEventListener('click', finish);
  document.getElementById('check').addEventListener('click', ()=>{
    const ok = isNormalForm(getM());
    narr(ok ? '✅ Matrix is in Normal Form: N = diag(I_r, 0).' : '❌ Not in Normal Form yet. Continue isolating pivots and zeroing outside the identity block.');
    drawLabels();
  });

  // Manual ops: rows
  document.getElementById('rSwapBtn').addEventListener('click', ()=>{
    const a=parseInt(document.getElementById('rSwapA').value);
    const b=parseInt(document.getElementById('rSwapB').value);
    const M=getM(); swapRows(M,a,b); writeBack(M); narr(`Swapped rows R${a+1} and R${b+1}.`);
  });
  document.getElementById('rScaleBtn').addEventListener('click', ()=>{
    const i=parseInt(document.getElementById('rScaleRow').value);
    const k=parseFloat(document.getElementById('rScaleK').value||'1');
    const M=getM(); scaleRow(M,i,k); writeBack(M); narr(`Scaled R${i+1} by ${k}.`);
  });
  document.getElementById('rAddBtn').addEventListener('click', ()=>{
    const d=parseInt(document.getElementById('rAddDest').value);
    const d2=parseInt(document.getElementById('rAddDest2').value);
    const s=parseInt(document.getElementById('rAddSrc').value);
    const k=parseFloat(document.getElementById('rAddK').value||'0');
    const dest = d; // UI uses both d and d2 for clarity; we keep dest=d
    const M=getM(); addRow(M,dest,s,k); writeBack(M); narr(`R${dest+1} ← R${dest+1} + (${k})·R${s+1}.`);
  });

  // Manual ops: columns
  document.getElementById('cSwapBtn').addEventListener('click', ()=>{
    const a=parseInt(document.getElementById('cSwapA').value);
    const b=parseInt(document.getElementById('cSwapB').value);
    const M=getM(); swapCols(M,a,b); writeBack(M); narr(`Swapped columns C${a+1} and C${b+1}.`);
  });
  document.getElementById('cScaleBtn').addEventListener('click', ()=>{
    const j=parseInt(document.getElementById('cScaleCol').value);
    const k=parseFloat(document.getElementById('cScaleK').value||'1');
    const M=getM(); scaleCol(M,j,k); writeBack(M); narr(`Scaled C${j+1} by ${k}.`);
  });
  document.getElementById('cAddBtn').addEventListener('click', ()=>{
    const d=parseInt(document.getElementById('cAddDest').value);
    const d2=parseInt(document.getElementById('cAddDest2').value);
    const s=parseInt(document.getElementById('cAddSrc').value);
    const k=parseFloat(document.getElementById('cAddK').value||'0');
    const dest = d;
    const M=getM(); addCol(M,dest,s,k); writeBack(M); narr(`C${dest+1} ← C${dest+1} + (${k})·C${s+1}.`);
  });

  // Init
  createGrid();
});
</script>
</body>
</html>
```
